<html>
  
  <head>
    <title>SPARQL 1.1 Secure Event (SE) Protocol</title>

    <!-- RESPEC CONFIGURATION -->
    <script src="http://pandora.aptest.com/w3c/respec-style/builds/respec-w3c-common.js" class="remove"></script>
    <script class='remove'>
      var respecConfig = {
      
        // document info
        specStatus:           "ED",
        shortName:            "sparql11seprotocol",      
        copyrightStart:       "2017",
        edDraftURI:           "http://github.com/desmovalvo/sparql11seprotocol-documentation",
        extraCSS:             ["css/respec.css"],
      
        // editors
        editors:  [{ 
          name: "Fabio Viola", 
          url: "http://wot.arces.unibo.it",
          mailto: "fabio.viola@unibo.it",
          company: "ARCES", 
          companyURL: "http://wot.arces.unibo.it" 
        },
        { 
          name: "Luca Roffia", 
          url: "http://wot.arces.unibo.it",
          mailto: "luca.roffia@unibo.it",
          company: "ARCES", 
          companyURL: "http:/wot.arces.unibo.it" 
        }],
      
        // WG
        wg:           "Web of Things working group of the ARCES laboratory",
        wgURI:        "http://wot.arces.unibo.it/",
      };
    </script>

  </head>

  <body>

    <!-- ABSTRACT -->
    <section id="abstract">
      This document describes the SPARQL 1.1 Secure Event (SE) 
      Protocol as an extension of the SPARQL 1.1 Protocol.
      The protocol introduces two new primitives to implement a 
      SPARQL based subscription mechanism.
    </section>

    <!-- STATUS OF THIS DOCUMENT -->
    <section id="sotd">
      This is a first draft.
    </section>   

    <!-- INTRODUCTION -->
    <section>
      
      <h2>The SPARQL 1.1 Secure Event (SE) Protocol</h2>

      <p>
	The SPARQL 1.1 SE Protocol is proposed as an extension of the SPARQL 1.1 Protocol [[sparql-11-protocol]].
	It is intended to be used in dynamic contexts where detecting events is critical.
	In such contexts, the use of SPARQL queries MAY be inefficient and MAY not guarantee to detect all the events
	because of their asynchronous nature. Moreover, the SPARQL 1.1 SE protocol is built around a security layer (e.g.,TLS) in order
	to be applied in environments where the security MUST be supported (e.g., the Internet of Things).	
	The SPARQL 1.1 SE Protocol extends the SPARQL 1.1 Protocol [[sparql-11-protocol]] 
	by adding two primitives: subscribe and unsubscribe. The SPARQL 1.1 Protocol is
	framed within the W3C Recommendations as shown in the following figure.
      </p>

	<img src="sparql11seprotocol.jpg">
    <center>Fig. 1 - SPARQL 1.1 Secure Event Protocol</center>

      <p>
	A SAP file MUST be a JSON document compliant with RFC 7159
	[[!RFC7159]].
      </p>


    </section>

    <!-- CORE OF THE DOCUMENT -->
    <section>

      <h2>Connection Parameters</h2>     
      
      <p>
	The section named <code>"parameters"</code> defines all the
	parameters needed to interact with an instance of the Semantic
	Event Processing Architecture (SEPA). In this section are
	defined parameters for the interaction with the HTTP interface
	(destined to SPARQL updates and SPARQL queries) and for the
	Websocket interface (needed for the SPARQL subscriptions).
	The value for the key <code>"parameters"</code> is a JSON
	object: its keys and values are specified in the next
	subsections.
      </p>
      
      <p>
	In order to connect to the HTTP interface of a SEPA the host,
	the ports (one for a secure connection, the other for an
	unsecure one) and the path to be appended must be known. Then
	the JSON object passed to the <code>"parameters"</code> key
	contains the keys <code>"host"</code> (without the
	leading <code>http://</code> or <code>https://</code>), the
	keys <code>"updatePort"</code> and <code>"updateSecurePort"</code>
	and <code>"path"</code>. Values of <code>"updatePort"</code>
	and <code>"updateSecurePort"</code> are numbers as defined in
	RFC7159 [[!RFC7159]].
      </p>	

      <p>
	Subscriptions play a crucial role in real-time
	applications. SEPA platform supports using the SPARQL Query
	[[rdf-sparql-query]] language to subscribe to
	events. Subscriptions use the websocket interface of SEPA
	platform. In order to configure access to websocket interface
	the ports for unsecure and secure connection must be specified
	as numbers to the keys <code>"subscribePort"</code>
	and <code>"subscribeSecurePort"</code>.
      </p>

      <p>
	An example of this configuration section is reported below:

	<pre class="example">"parameters" : { 
    "host":"my.sepa.host.com",
    "path":"/sparql",
    "updateSecurePort":8443, 
    "updatePort":8000,
    "subscribeSecurePort":9443, 
    "subscribePort":9000	    
}</pre>
      </p>

      <p>
	A SAP file SHOULD contain all of the above-mentioned keys.
      </p>
      
    </section>

    <section>
      <h2>Namespaces</h2>       

      <p>
	In a SAP file namespaces can be defined. Client-side APIs will
	take the namespaces and prepend them to a SPARQL
	update/query/subscription. In a SAP file namespaces are
	specified as a JSON object assigned to the
	key <code>"namespaces"</code>. In this object every key
	represents a prefix, while the value is the relative
	namespace.
      </p>

      <p>
	In the following example the well known <code>rdf</code>
	and <code>rdfs</code> prefixes are defined in the SAP file:

	<pre class="example">"namespaces" : {
    "rdf":"http://www.w3.org/1999/02/22-rdf-syntax-ns#",
    "rdfs":"http://www.w3.org/2000/01/rdf-schema#"
}</pre>
      </p>
      
    </section>

    <section>
      <h2>Updates</h2>
      
      <p>
	A SAP file includes a list of the SPARQL updates (see
	[[RDF-SPARQL-UPDATE]]) performed by the application. The
	updates MUST be specified as a JSON object passed to
	the <code>"updates"</code> key. In this object every key
	represent the friendly name of the SPARQL update. The value is
	a JSON object in which the main key is
	named <code>"sparql"</code> and contains the SPARQL code.
      </p>

      <p>
	The following example shows the definition of a very basic
	SPARQL update named <code>INSERT_PERSON</code>:
	
	<pre class="example">
"updates" : {
  "INSERT_PERSON" : { "sparql":"INSERT DATA { &lt;http://ns#Person1&gt; rdf:type foaf:Person }" }
}
	</pre>

	In a SPARQL update containing literals, quotes MUST be
	escaped.
	
      </p>

      <section>
	<h3>Forced Bindings</h3>
      
      <p>
	The usefulness of a SAP profile consists in the ability to
	create templates for SPARQL updates that can be fetched by the
	application and modified at run-time to fit the actual
	need. For example a producer that updates the value of a
	temperature sensor will only need to fill a field in the
	template. Here is where the definition of forced bindings
	comes in help. A forced binding enables the developer to
	substitute a variable in a template with a custom value. To
	define forced bindings for a SPARQL update, the
	key <code>"forcedBindings"</code> MUST be used. The value is a
	JSON object. The variable of a forced binding is a key in that
	JSON object. Its value is again a JSON object containing the
	keys <code>"type"</code>
	and <code>"value"</code>. <code>"type"</code> MUST be one
	of <code>"uri"</code>, <code>"bnode"</code>, <code>"literal"</code>.
      </p>

      <p>
	Now that forced bindings have been defined, we can write an
	example of SPARQL update template. In the following example 
      <pre class="example">
"ADD_PERSON":{
"sparql":"INSERT DATA { ?person rdf:type iot:Person . ?person iot:hasName ?name }",
    "forcedBindings": {
        "person" : {"type":"uri", "value":""},
        "name" : {"type":"literal", "value":""}
    }
}
      </pre>
      </p>      
      </section>
      
    </section>
      
    <section>
      <h2>Subscriptions</h2>

      <p>
	Queries and persistent queries, named subscriptions, MUST be
	defined in accord to SPARQL Query Language
	[[rdf-sparql-query]]. While a SPARQL query MUST be sent over
	HTTP (or HTTPS), a SPARQL subscription MUST be issued over
	Websocket (secure or unsecure). Both queries and
	subscriptio-ns are defined using the <code>"subscribes"</code>
	key of the main JSON object. As for SPARQL updates, each
	query/subscription has a friendly name, which is a key in the
	JSON object assigned to the key <code>"subscribes"</code>.
	The JSON object describing a query/subscription MUST contain
	the <code>"sparql"</code> key.
      </p>

      <p>
	In the following example a very
	simple <code>"subscribe"</code> section is presented. Only a
	SPARQL query/subscription related to the whole knowledge-base
	is present. No forced bindings are defined.
	
	<pre class="example">
"subscribes" : {
    "EVERYTHING" : {	
        "sparql" : "SELECT ?s ?p ?o WHERE  { ?s ?p ?o }"
    }
}
	</pre>
	
      </p>

      <section>
	<h3>Forced Bindings</h3>
	
	<p>
	  The JSON object of a SPARQL query/subscription MAY contain the
	  keys <code>"forcedBindings"</code>. In that case the value
	  of <code>"forcedBindings"</code> is a JSON object that MUST
	  contain the keys <code>"type"</code> and <code>"value"</code>.
	  
	  The following example shows a template for a SPARQL
	  query/subscription containing forced bindings.

	  <pre class="example">
"subscribes" : {
    "tempSensor" : {	
        "sparql" : "SELECT ?temp WHERE  { ?tempSens rdf:type iot:TempSensor . ?tempSens iot:hasValue ?temp }",
        "forcedBindings" : {
            "temp": {"type":"uri", "value":""}
        }
    }
}	    
	  </pre>
	  
	</p>
      </section>
      
    </section>

    <section>
      <h2>Example</h2>

      In this section a Minimum Working Example (MWE) is presented.

      <pre class="example">
{
    "parameters" : { "path":"sparql",
		     "subscribeSecurePort":9443, "subscribePort":9000,
		     "updateSecurePort":8443, "updatePort":8000,
		     "host":"my.sepa.host.com"},
    "namespaces" : { "iot":"http://www.arces.unibo.it/iot#",
		     "rdf":"http://www.w3.org/1999/02/22-rdf-syntax-ns#"},
    "updates": {
	"ADD_PERSON":{
	    "sparql":"INSERT DATA { ?person rdf:type iot:Person . ?person iot:hasName ?name }",
	    "forcedBindings": {
		"person" : {"type":"uri", "value":""},
		"name" : {"type":"literal", "value":""}}}
    },    
    "subscribes": {
	"CLASS_INSTANCES":{
	    "sparql":"SELECT ?s WHERE { ?s rdf:type ?class }",
	    "forcedBindings": {
		"class" : {"type":"uri", "value":""}}},
	"EVERYTHING":{	
	    "sparql":"SELECT ?s ?p ?o WHERE  { ?s ?p ?o }"}
    }
}	
      </pre>
      
    </section>
    
    <!-- APPENDIX -->
    <section class="appendix">

      <!-- ACKNOWLEDGEMENTS -->
      <h2>Acknowledgements</h2>
      <p>
	Authors would like to thanks the Advanced Research Center on Electronic Systems (ARCES) of the University of Bologna.
      </p>

    </section>


  </body>

</html>
