<html>

<head>
<title>JSON SPARQL Application Profile (JSAP)</title>
<!-- RESPEC CONFIGURATION -->
<script
	src="http://pandora.aptest.com/w3c/respec-style/builds/respec-w3c-common.js"
	class="remove"></script>
<script class='remove'>
      var respecConfig = {
      
        // document info
        specStatus:           "unofficial",
        shortName:            "jsap",      
        copyrightStart:       "2017",
        edDraftURI:           "http://wot.arces.unibo.it/TR/jsap.html",
        extraCSS:             ["css/respec.css"],
      
        // editors
        editors:  [
        { 
          name: "Cristiano Aguzzi", 
          url: "http://wot.arces.unibo.it",
          mailto: "cristiano.aguzzi@studio.unibo.it",
          company: "ARCES", 
          companyURL: "http://wot.arces.unibo.it" 
        },
         { 
          name: "Francesco Antoniazzi", 
          url: "http://wot.arces.unibo.it",
          mailto: "francesco.antoniazzi@unibo.it",
          company: "ARCES", 
          companyURL: "http://wot.arces.unibo.it" 
        },
        { 
          name: "Luca Roffia", 
          url: "http://wot.arces.unibo.it",
          mailto: "luca.roffia@unibo.it",
          company: "DISI", 
          companyURL: "http://wot.arces.unibo.it" 
        },
        { 
          name: "Fabio Viola", 
          url: "http://wot.arces.unibo.it",
          mailto: "fabio.viola@unibo.it",
          company: "ARCES", 
          companyURL: "http://wot.arces.unibo.it" 
        }
        ],
        // WG
        wg:           "Web of Things working group @ ARCES University of Bologna",
        wgURI:        "http://wot.arces.unibo.it/",
      };
    </script>

</head>

<body>

	<!-- ABSTRACT -->
	<section id="abstract">
		This document describes the JSON SPARQL Application Profile (JSAP).
		JSAP is used to describe an application based on the <a
			href="http://wot.arces.unibo.it/TR/sepa.html">SPARQL Event
			Processing Architecture</a> (SEPA) and following the application design
		pattern named <b>PAC</b> (<b>P</b>roducer-<b>A</b>ggregator-<b>C</b>onsumer)
		described in this document. JSAP uses JSON as default format
		[[!RFC7159]] .
	</section>

	<!-- STATUS OF THIS DOCUMENT -->
	<section id="sotd">This is a first draft.</section>

	<!-- INTRODUCTION -->
	<section id="introduction">

		<h2>Introduction</h2>

		<p>
			This document first presents the concept of SPARQL Application
			Profile from a developer point a view. Developers are RECOMMENDED to
			follow the PAC design pattern presented in this document (i.e., an
			application is composed by a set of producers, consumers and
			aggregators). The role of JSAP is to collect the <b>SPARQL
				updates</b> [[sparql11-update]], <b><a
				href="http://wot.arces.unibo.it/TR/sparql11-subscribe.html">SPARQL
					subscribes</a></b> and the <b>connection parameters</b> used by a SEPA
			application. JSAP MAY contain a list of SPARQL prefixes. In such a
			way, JSAP acts as an <i>identity card</i> of a SEPA application.
		</p>

		<p>
			A JSAP file MUST be a JSON document compliant with RFC 7159
			[[!RFC7159]] and SHOULD NOT be modified at runtime, as it describes
			the application scope. The need of runtime modifications of the JSAP
			file is to be considered as a bad practice.
			<!--Instead, the Authors suggest the use of more than one JSAP file or, of course, the review of the SPARQL code.-->
		</p>

		<section id="conventions">
			<h3>Document conventions</h3>
			When this document uses the words MUST, MUST NOT, SHOULD, SHOULD NOT,
			MAY and RECOMMENDED, and the words appear as emphasized text, they
			must be interpreted as described in RFC 2119 [[!RFC2119]].
		</section>

		<section id="terms">
			<h3>Terminology</h3>
			<dt>JSAP</dt>
			<dd>
				JSON SPARQL Application Profile (as defined by this <a
					href="http://wot.arces.unibo.it/TR/jsap.html">document</a>)
			</dd>
			<dt>SPARQL</dt>
			<dd>SPARQL Protocol and RDF Query Language (as defined by
				[[sparql11-overview]])</dd>

			<dt>SPARQL 1.1 Update Language</dt>
			<dd>As defined by [[sparql11-update]]</dd>

			<dt>SPARQL 1.1 Query Language</dt>
			<dd>As defined by [[sparql11-query]]</dd>

			<dt>SPARQL 1.1 Subscribe Language</dt>
			<dd>
				The <a href="http://wot.arces.unibo.it/TR/sparql11-subscribe.html">subscription
					language</a> introduced by the SEPA
			</dd>

			<dt>SPARQL 1.1 SE Protocol</dt>
			<dd>
				The <a href="http://wot.arces.unibo.it/TR/sparql11-se-protocol.html">protocol</a>
				implemented by a SEPA engine
			</dd>

			<dt>SEPA</dt>
			<dd>
				<a href="http://wot.arces.unibo.it/TR/sepa.html">SPARQL Event
					Processing Architecture</a>
			</dd>

			<dt>SEPA application</dt>
			<dd>
				a collection of producers, consumers and aggregators (as defined by
				this <a href="http://wot.arces.unibo.it/TR/jsap.html">document</a>)
			</dd>

			<dt>SEPA engine</dt>
			<dd>
				The server component of the SEPA. It implements the
				publish-subscribe mechanisms and algorithms. Clients interact with a
				SEPA engine with the <a
					href="http://wot.arces.unibo.it/TR/sparql11-se-protocol.html">SPARQL
					1.1 SE Protocol</a>
			</dd>
		</section>
	</section>

	<!-- CORE OF THE DOCUMENT -->
	<section id="pac-pattern">

		<h2>PAC design pattern</h2>
		<p>The following figure gives an overview of the RECOMMENDED
			application design pattern to be followed by SEPA applications
			developers.</p>

		<img src="images/pac-pattern.jpg">
		<p>
			Fig. 1 - The SEPA application design pattern also know as
			"PAC-Pattern" (<b>P</b>roducer-<b>A</b>ggregator-<b>C</b>onsumer)
		</p>
		<p>
			The design pattern assumes that a client SHOULD interact with a SEPA
			engine using two primitives: <b>update</b> and <b>subscribe</b>. The
			protocol used by a client to interact with a SEPA engine is described
			in <a href="http://wot.arces.unibo.it/TR/sparql11-se-protocol.html">SPARQL
				1.1 Secure Event Protocol</a>. While an update corresponds to a SPARQL
			1.1 Update [[sparql11-update]], a subscribe is described in <a
				href="http://wot.arces.unibo.it/TR/sparql11-subscribe.html">SPARQL
				1.1 Subscribe Language</a>. A subscribe acts as a persistent SPARQL 1.1
			Query [[sparql11-query]] and the content of a notification contains
			the <i>delta</i> of the results since the previous notification
			(i.e., when a subscribe is invoked the current query results are
			returned to the client) as described in <a
				href="http://wot.arces.unibo.it/TR/sparql11-subscribe.html">SPARQL
				1.1 Subscribe Language</a>. A client assumes a different role depending
			on how it interacts with a SEPA engine.
		</p>
		<p></p>
		<p>
			A <i>producer</i> invokes a SPARQL 1.1 Update [[sparql11-update]] and
			such update MUST be always the same (i.e., see <b><a
				href="#forcedBindings">forced bindings</a></b>). A sensor producing some
			measures is an example.
		</p>
		<p>
			A <i>consumer</i> invokes a <a
				href="http://wot.arces.unibo.it/TR/sparql11-subscribe.html">SPARQL
				1.1 Subscribe</a>. Like the update of a producer, a consumer MUST invoke
			one and only one subscribe. When a consumer subscribes, it MAY
			replace some variables within the <a
				href="http://wot.arces.unibo.it/TR/sparql11-subscribe.html">SPARQL
				1.1 Subscribe</a> with actual values (i.e., see <b><a
				href="#forcedBindings">forced bindings</a></b>). An actuator subscribed
			to events (or commands) is an example.
		</p>
		<p>
			An <i>aggregator</i> acts as follows: when it receives a
			notification, it processes the notification content and invokes an
			update (if needed). The processing of an aggregator can be
			combinatorial or sequential. In the former case there is no need of
			an internal <i>context memory</i>. To be classified as aggregator, a
			relation between the notification and the corresponding update SHOULD
			exist (i.e., an aggregator is not the sum of a producer and a
			consumer). In the PAC pattern, <b>aggregators implement the
				application business logic</b>.
		</p>

		<p class='note' title='PAC the Web of Things'>
			The PAC pattern MAY be attractive for <b>Web of Things</b>
			applications: producers and consumers interact with the physical
			world and SHOULD be kept as simpler as possible. Aggregators MAY be
			more resources greedy (e.g., MAY run on a high performance server
			machine). This distinction is also very important for reuse and
			modularization: the same set of producers and consumers can be
			re-used in other applications and the application business logic can
			be changed (or extended) just by adding (or extending) aggregators.
		</p>
		<p>
	</section>

	<section id="JSAPcontent">
		<h2>JSAP content</h2>
		<p>
			JSAP can be logically divided in four main sections, each of them
			described by a JSON object. These JSON objects are:
			<code>parameters</code>
			,
			<code>namespaces</code>
			,
			<code>updates</code>
			and
			<code>subscribes</code>
			. For each of these objects, a specific sub-section follows.
		</p>

		<section id="connectionParameters">

			<h3>Connection parameters</h3>
			<p>
				A semantic application profile, in order to fully describe an
				application, MUST contain the <b>connection parameters</b> needed by
				an application to interact with a SEPA engine instance through the <a
					href="http://wot.arces.unibo.it/TR/sparql11-se-protocol.html">SPARQL
					1.1 SE Protocol</a>, like the HTTPS interface (used by secure SPARQL
				updates and SPARQL queries) and the Websocket interface (needed by
				(secure) SPARQL subscriptions). In JSAP, such parameters are
				described by a mandatory a JSON object named
				<code>"parameters"</code>
				that MUST contain all the following keys:
				<code>"host"</code>
				,
				<code>"ports"</code>
				and
				<code>"paths"</code>
				.
			<pre class="example" title="Connection parameters" id="ConnectionParametersExample">
"parameters": {
  "host": "wot.arces.unibo.it",
  "ports": {
    "http": 8000,
    "https": 8443,
    "ws": 9000,
    "wss": 9443
  },
  "paths": {
    "query": "/query",
    "update": "/update",
    "subscribe": "/subscribe",
    "register": "/oauth/register",
    "tokenRequest": "/oauth/token",
    "securePath": "/secure"
}}</pre>

			<p>
				The value of the
				<code>"host"</code>
				member specifies the host where the SEPA engine is running (e.g.,
				wot.arces.unibo.it).
			</p>
			<p>
				The
				<code>"ports"</code>
				member contains a list of the ports where the SEPA engine is
				listening for SPARQL 1.1 SE primitives:
				<code>"http"</code>
				for updates and queries,
				<code>"https"</code>
				for secure updates, queries and authorization requests,
				<code>"ws"</code>
				and
				<code>"wss"</code>
				respectively for unsecure and secure subscribes.
			</p>
			<p>
				The
				<code>"paths"</code>
				member contains the paths used to form the URLs used by SPARQL 1.1
				SE primitives, like
				<code>"query"</code>
				,
				<code>"update"</code>
				and
				<code>"subscribe"</code>
				. A SEPA engine implementation MUST also provide two more
				primitives: <b>register</b> and <b>token request</b>. The former is
				used by clients to obtain <i>credentials</i>, while the latter to
				request <i>JSON Web Tokens (JWT)</i> (i.e., JWT are needed to invoke
				secure primitives). The path included in the URLs of these
				primitives is specified respectively by the value of
				<code>"register"</code> and <code>"tokenRequest"</code>.
				The URLs of secure primitives (i.e., secure query, secure update and
				secure subscribe) are obtained by adding at the beginning of the
				path what is specified by the
				<code>"securePath"</code>
				member value.
			</p>
			The URLs obtained from the <a
					href='ConnectionParametersExample'>above JSON</a> follow:
			<pre class="example"
				title="URLs used by SEPA primitives">
<a href="https://www.w3.org/TR/sparql11-protocol/">SPARQL 1.1 Protocol</a>

- Query URL: http://wot.arces.unibo.it:8000/query

- Update URL: http://wot.arces.unibo.it:8000/update

<a href="https://wot.arces.unibo.it/TR/sparql11-se-protocol/">SPARQL SE 1.1 Protocol</a>

- Subscribe on: ws://wot.arces.unibo.it:9000/subscribe

- SECURE Query URL: https://wot.arces.unibo.it:8443/secure/query

- SECURE Update URL: https://wot.arces.unibo.it:8443/secure/update

- SECURE Subscribe on: wss://wot.arces.unibo.it:9443/secure/subscribe

- Registration URL: https://wot.arces.unibo.it:8443/oauth/register

- Token request URL: https://wot.arces.unibo.it:8443/oauth/token</pre>
			<p>
				JSAP MAY also be used by clients to store credentials (i.e., <i>clientId</i>
				and <i>clientSecret</i>) and JSON Web Token. For security reasons,
				it is RECOMMENDED to encrypt those elements (e.g., using <a
					href="https://dx.doi.org/10.6028/NIST.FIPS.197">Advanced
					Encryption Standard (AES)</a>) like in the following example:
			</p>
			<pre class="note" title="Storing client credentials">
"parameters":{
  "security":{
    "clientId":"TP6...RPC9",
    "clientSecret":"SVEM...+EPFU",
    "jwt":"XABTQ...HVMWXCCK=",
    "expires":"DSBUAXCGHRFQ2GGALQDUSQ==",
    "type":"XPRHEX2XHY+5IUXHPHIGMW=="
  }
}
</pre>
		</section>

		<section>
			<h3>Namespaces</h3>

			<p>
				JSAP MAY include a set of namespaces used by SPARQL updates and
				queries. Client-side APIs SHOULD take the namespaces and prepend
				them to a SPARQL update/subscribe. This allows to simplify the
				SPARQL text by using qualified names for URIs [[xml-names]].
				Namespaces are specified as a JSON object assigned to the key
				<code>"namespaces"</code>
				. In this object, every key represents a prefix, while the value is
				the relative namespace.
			</p>

			<p>
				In the following example the well known
				<code>rdf</code>
				and
				<code>rdfs</code>
				prefixes are defined in JSAP:
			</p>
			<pre class="example" title="Namescapes">
"namespaces" : {
  "rdf":"http://www.w3.org/1999/02/22-rdf-syntax-ns#",
  "rdfs":"http://www.w3.org/2000/01/rdf-schema#",
  "wot":"http://wot.arces.unibo.it/wot#
}
</pre>

		</section>

		<section>
			<h3>Updates</h3>

			<p>
				JSAP MAY include a JSON object named
				<code>"updates"</code>
				listing all the SPARQL 1.1 Updates [[sparql11-update]] used by the
				application.
			</p>
			<p>
				A single update is specified by a JSON object where the key is the
				friendly name of the update, while the value is a JSON object with a
				mandatory key named
				<code>"sparql"</code>
				whose value is the SPARQL 1.1. Update [[sparql11-update]] string.
			</p>

			<p>
				In the following example, an
				<code>"updates"</code>
				section including a single update named
				<code>UPDATE_ALL_TO_100</code>
				is presented.
			</p>
			<pre class="example" title="Update (sensor)">
"updates" : {
  "UPDATE_ALL_TO_100" : {
    "sparql":"
      DELETE {?sensor wot:hasValue ?oldValue}
      INSERT {?sensor wot:hasValue "100" . ?sensor rdf:type wot:SENSOR}
      WHERE {OPTIONAL{?sensor rdf:type wot:SENSOR . ?sensor wot:hasValue ?oldValue}}"
  }
}</pre>

			<p>
				<b>Note</b>: quotes in literals MUST be escaped.
			</p>

		</section>

		<section>
			<h3>Subscribes</h3>

			<p>
				A subscribe, MUST be defined according to the <a
					href="http://wot.arces.unibo.it/TR/sparql11-subscribe.html">SPARQL
					1.1 Subscribe Language</a>. As described by <a
					href="http://wot.arces.unibo.it/TR/sparql11-se-protocol.html">SPARQL
					1.1 SE Protocol</a>, a SPARQL 1.1 Subscribe is RECOMMENDED to be sent
				over a Websocket (secure or unsecure).
			</p>
			<p>
				In JSAP, subscribes are listed by the
				<code>"subscribes"</code>
				JSON object. As for the updates, each subscribe has a friendly name,
				which is the key of a JSON object children of
				<code>"subscribes"</code>
				. The JSON object describing a subscribe MUST contain the
				<code>"sparql"</code>
				key.
			</p>

			<p>
				In the following example, a
				<code>"subscribes"</code>
				section including a single subscribe named
				<code>SENSOR</code>
				is presented.
			</p>
			<pre class="example" title="Subscribe (actuator)">
"subscribes" : {
  "ALL_SENSORS_VALUES" : {
    "sparql" : "
      SELECT ?sensor ?value 
      WHERE  {?sensor rdf:type wot:SENSOR . ?sensor wot:hasValue ?value}"
    }
}

	</pre>
		</section>
	</section>
	<section id="forcedBindings">
		<h2>Forced Bindings</h2>

		<p>
			The main benefit of JSAP consists in the ability of creating
			templates for applications. Those templates act also as an <i>identity
				card</i> of an application.
		</p>
		<p>
			SPARQL updates and subscribes can be fetched by the application and
			modified at run-time to fit the application needs. For example, a
			producer that updates the value of a temperature sensor will only
			need to fill a field in the template (i.e., the current value). Here
			is where the definition of <i>forced bindings</i> comes in help. A
			forced binding enables the developer to substitute at run-time a
			variable in a template with a custom value.
		</p>
		<p>
			To define forced bindings, the key
			<code>"forcedBindings"</code>
			MUST be used. The value is a JSON object. The variable of a forced
			binding is a key in that JSON object. Its value is again a JSON
			object containing the keys
			<code>"type"</code>
			and
			<code>"value"</code>
			.
			<code>"type"</code>
			is mandatory and MUST be one of
			<code>"uri"</code>
			,
			<code>"bnode"</code>
			,
			<code>"literal"</code>
			. The
			<code>"value"</code>
			key is optional and SHOULD be used to specify a <i>default</i> value
			for that variable.
		</p>

		<p>Now that forced bindings have been defined, we can write an
			example of a SPARQL update template.</p>
		<pre class="example" title="Update template with forced bindings">
"UPDATE_SENSOR_VALUE":{
  "sparql":"
    DELETE {<b>?sensor</b> wot:hasValue ?oldValue} 
    INSERT {<b>?sensor</b> wot:hasValue <b><code>?value</code></b> . <b>?sensor</b> rdf:type wot:SENSOR} 
    WHERE {OPTIONAL{<b>?sensor</b> rdf:type wot:SENSOR . <b>?sensor</b> wot:hasValue ?oldValue} }"
  "forcedBindings": {
    "<b>sensor</b>" : {"type":"uri", "value":""},
    "<b>value</b>" : {"type":"literal", "value":""}
  }
}</pre>
		<p>
			The
			<code>UPDATE_SENSOR_VALUE</code>
			update is very similar to the
			<code>UPDATE_ALL_TO_100</code>
			update. In the SPARQL text, the literal value
			<code>"100"</code>
			has been replaced by the variable <b><code>?value</code></b> . As the
			forced bindings include both <b><code>sensor</code></b> and <b><code>value</code></b>
			variables, a client MUST bind such variables before calling the
			update.
		</p>
		<p>The effective SPARQL update would look the the following:</p>
		<pre class="example" title="Update filled with forced bindings">

DELETE {<b>wot:A_SENSOR_URI</b> wot:hasValue ?oldValue} 
INSERT {<b>wot:A_SENSOR_URI</b> wot:hasValue <b><code>"the value of the sensor reading"</code></b> . <b>wot:A_SENSOR_URI</b> rdf:type wot:SENSOR} 
WHERE {OPTIONAL{<b>wot:A_SENSOR_URI</b> rdf:type wot:SENSOR . <b>wot:A_SENSOR_URI</b> wot:hasValue ?oldValue} }"
</pre>
		<p>
			The same applies to subscribes. For example, the
			<code>ALL_SENSORS_VALUES</code>
			subscribe is triggered on every changes in the value of all sensors,
			while the following subscribe (named
			<code>SENSOR_VALUE</code>
			) can be used to be notified on changes in the value of a specific
			sensor:
		<pre class="example" title="Subscribe template with forced bindings">			
"SENSOR_VALUE" : {	
  "sparql" : "
    SELECT ?value 
    WHERE  {<b><code>?sensor</code></b> rdf:type wot:SENSOR . <b><code>?sensor</code></b> wot:hasValue ?value}",
  "forcedBindings": {
    "<b>sensor</b>" : {"type":"uri", "value":""}
  }
}			
</pre>
		<p>The effective SPARQL subscribe would look the the following:</p>
		<pre class="example" title="Subscribe filled with forced bindings">			
SELECT ?value 
WHERE  {<b><code>wot:A_SENSOR_URI</code></b> rdf:type wot:SENSOR . <b><code>wot:A_SENSOR_URI</code></b> wot:hasValue ?value}</pre>
	</section>
	<section>
		<h2>Minimum Working Example (MWE)</h2>

		In this section a Minimum Working Example (MWE) of a JSAP is
		presented.

		<pre class="example">
{"parameters": {
  "host": "wot.arces.unibo.it",
  "path": "/sparql",
  "scheme": "http",
  "port": 8000,
  "subscribe": {"scheme": "ws","port": 9000},
  "secureQuery": {"port": 8443,"scheme": "https"},
  "secureUpdate": {"port": 8443,"scheme": "https"},
  "secureSubscribe": {"scheme": "wss","port": 9443,"path": "/secure/sparql"},
  "authorizationServer": {
    "port": 8443,
    "scheme": "https",
    "register": "/oauth/register",
    "requestToken": "/oauth/token"},
  },
"namespaces" : {
  "rdf":"http://www.w3.org/1999/02/22-rdf-syntax-ns#",
  "rdfs":"http://www.w3.org/2000/01/rdf-schema#",
  "wot":"http://wot.arces.unibo.it/wot#
}
"updates" : {
  "UPDATE_ALL_TO_100" : { 
    "sparql":"
      DELETE {?sensor wot:hasValue ?oldValue} 
      INSERT {?sensor wot:hasValue "100" . wot:SENS_URI_1 rdf:type wot:SENSOR} 
      WHERE {OPTIONAL{?sensor rdf:type wot:SENSOR . ?sensor wot:hasValue ?oldValue} }",
  "UPDATE_SENSOR_VALUE":{
    "sparql":"
      DELETE {?sensor wot:hasValue ?oldValue} 
      INSERT {?sensor wot:hasValue ?value . wot:SENS_URI_1 rdf:type wot:SENSOR}
      WHERE {OPTIONAL{?sensor rdf:type wot:SENSOR . ?sensor wot:hasValue ?oldValue} }"
    "forcedBindings": {
      "sensor" : {"type":"uri", "value":""},
      "value" : {"type":"literal", "value":""}
       }
     }
   },
"subscribes": {
  "ALL_SENSORS_VALUES" : {	
    "sparql" : "
      SELECT ?sensor ?value 
      WHERE  {?sensor rdf:type wot:SENSOR . ?sensor wot:hasValue ?value}"
     }
  "SENSOR_VALUE" : {	
    "sparql" : "
      SELECT ?value 
      WHERE  {?sensor rdf:type wot:SENSOR . ?sensor wot:hasValue ?value}",
    "forcedBindings": {
      "sensor" : {"type":"uri", "value":""}
     }
    }
  }
}</pre>

	</section>

	<!-- APPENDIX -->
	<section class="appendix">

		<!-- ACKNOWLEDGEMENTS -->
		<h2>Acknowledgements</h2>

		<p>
			Editors would like to thanks the <a
				href="http://www.arces.unibo.it/en">Advanced Research Center on
				Electronic Systems "Ercole De Castro" (ARCES)</a> and the <a
				href="http://www.cse.unibo.it/en/index.html">Computer Science
				and Engineering Department (DISI)</a> of the <a
				href="http://http://www.unibo.it/en/homepage">University of
				Bologna</a>, the <a href="https://ec.europa.eu/commission/index_en">European
				Commission</a> and all the partners of the <a
				href="https://artemis-ia.eu/">ARTEMIS</a> projects who inspired the
			SPARQL Event Processing Architecture (SEPA).
		</p>
	</section>

	</section>
</body>

</html>
